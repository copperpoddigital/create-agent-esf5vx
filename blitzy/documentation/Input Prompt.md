## WHY - Vision & Purpose

### Purpose & Users

**Problem being solved:**  
This backend system provides APIs for document management and enables users to interact with a chatbot that can search and retrieve information from documents stored in a vector database. The system utilizes AI (Agentic Chatbot) capabilities to answer queries by leveraging document content and vector search.

**Target Users:**

- **Common Users:** Users who want to search through stored documents and ask questions, getting responses based on the content stored.

- **Businesses:** Organizations that need a lightweight document search solution with AI-based answers for internal or customer-facing knowledge bases.

- **Knowledge Workers:** Researchers, educators, and professionals who want to search through large amounts of documents and extract relevant insights quickly.

----------

## WHAT - Core Requirements

### Functional Requirements

The system must expose the following APIs to handle document management, querying, and the agent-based chatbot functionality:

1. **Document Management API:**

   - **POST /documents/upload:** Upload documents (PDFs) into the system, converting them into vector embeddings and storing them in a FAISS vector database.

   - **GET /documents/list:** Retrieve a list of uploaded documents with metadata like size and name.

   - **DELETE /documents/{document_id}:** Delete a document from the system by its ID.

   - **GET /documents/{document_id}:** View details or the content of a specific document.

2. **Vector Search API:**

   - **POST /query:** Submit a search query. The system will perform a vector search in FAISS and return the most relevant documents and a chatbot-generated response based on those documents.

   - **GET /query/{query_id}:** Retrieve the results of a specific query, including response context and document matches.

3. **Reinforcement Learning API (Basic Implementation):**

   - **POST /feedback:** Submit user feedback (e.g., thumbs up or thumbs down) for responses generated by the chatbot.

   - **GET /feedback/{query_id}:** Retrieve feedback information for a specific query.

   - **POST /reinforce:** Trigger the process of updating the chatbotâ€™s behavior based on accumulated feedback.

----------

## HOW - Planning & Implementation

### Technical Implementation

**Required Stack Components:**

- **Backend:**

  - **API Framework:** Python-based backend using **FastAPI** or **Flask**.

  - **Document Storage and Vector Database:** Use **FAISS** for vector storage and search, with document metadata (titles, authors, etc.) stored in a relational database or **SQLite** (for simplicity).

  - **LLM Integration:** Use an LLM (like OpenAI's GPT-3/4 or any open-source alternative) to generate answers based on the search results.

- **Document Upload & Processing:**

  - **PDF Parsing:** Use libraries like **PyMuPDF** or **pdfplumber** for extracting text from PDF documents.

  - **Vectorization:** Use **Sentence Transformers** or **OpenAI embeddings** to convert document text into vector embeddings, which will then be indexed in FAISS.

- **Reinforcement Learning (RL):**

  - For simplicity, we can integrate a basic RL system using **Ray RLlib** or a custom model that refines response generation based on user feedback.

- **Database:**

  - **Relational Database:** Use **SQLite** (or PostgreSQL in the future for scalability) to store document metadata (e.g., title, date uploaded).

  - **FAISS:** Use FAISS for storing and querying the document embeddings.

- **Infrastructure (Monolithic):**

  - Initially, the app will be monolithic, but we can structure the code with future scalability in mind (e.g., modular components for document management, vector search, and RL).

### System Requirements

- **Performance:**

  - Document search and vector processing should be completed within 3 seconds.

  - The system should handle document uploads of up to 1GB with each PDF file not exceeding 10MB.

- **Security:**

  - Use **JWT tokens** for secure API access.

  - Ensure data encryption for document uploads and stored embeddings.

- **Scalability:**

  - While the initial app is monolithic, the system should be designed with modularity in mind to allow easy migration to a microservice architecture in the future (e.g., separating document storage, query handling, and RL).

- **Reliability:**

  - Aim for 99.9% uptime and handle large file uploads and queries efficiently.

----------

## Business Requirements

**Access & Authentication:**

- **User Types:**

  - **Regular Users:** Can upload, view, and search documents, and interact with the chatbot.

  - **Admin Users:** Can manage documents and review feedback.

- **Authentication:**

  - Use **JWT-based authentication** to secure user access.

- **Permissions:**

  - **Admin permissions** for document management (upload, delete, list).

  - **Regular users** can only upload, view, and search documents.

----------

## Implementation Priorities

### **High Priority:**

1. **Document Upload & Search APIs:**

   - Implement APIs for uploading, deleting, viewing, and listing documents.

   - Implement FAISS for storing and searching document embeddings.

2. **LLM Integration and Query Handling:**

   - Integrate the LLM to process user queries and return responses based on document content.

3. **Basic Feedback and Reinforcement Learning:**

   - Implement the feedback API for collecting user ratings on chatbot responses.

   - Add a basic RL system to improve response quality over time based on user feedback.

### **Medium Priority:**

1. **Document Metadata Management:**

   - Store document metadata (title, upload date, file size) for better document search and management.

2. **Search Optimization:**

   - Implement improvements to vector search (e.g., ranking based on document relevance).

### **Lower Priority:**

1. **Advanced RL Implementation:**

   - Enhance the RL model to handle more sophisticated learning, such as understanding query intent or adapting to new documents more effectively.

2. **Monitoring & Analytics:**

   - Add a system to monitor query success rates, document hits, and user feedback.  
       
     Use python, fastapis, postgresql/FAISS 